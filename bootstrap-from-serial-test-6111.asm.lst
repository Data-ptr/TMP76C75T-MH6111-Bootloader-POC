0001   0000             ; MH6111/TMP76C75T Bootstrap from Serial test code (TASM)
0002   0000             ; Jane Hacker
0003   0000             ; 9th Feb 2022
0004   0000             ;
0005   0000             ; XTAL = 12MHz, E = 12MHz/6 = 2MHz
0006   0000             ; 0x07: Baud rate = 2Mhz/4096 = 488 Baud (Nice and slow)
0007   0000             ; 0x05: Baud rate = 2Mhz/128 = 15,625 Baud
0008   0000             ; 0x04: Baud rate = 2Mhz/16 = 125,000 Baud (Holy smokes!)
0009   0000             ;
0010   0000             ; Run in Mode 2, Multiplexed/RAM/No ROM, P20: L, P21: H, P22: L
0011   0000             ;
0012   0000                                 .msfirst
0013   0000             ;
0014   0000             ;Internal registers
0015   0000             SCI_BAUD            .equ    $0010
0016   0000             SCI_SCR             .equ    $0011
0017   0000             SCI_RX              .equ    $0012
0018   0000             SCI_TX              .equ    $0013
0019   0000             RAM_CTL             .equ    $0014
0020   0000             ;
0021   0000             ;RAM
0022   0000             RAM_BOT             .equ    $0040       ;The bottom of stored RAM
0023   0000             MC_START            .equ    $0040
0024   0000             MC_STOP             .equ    $0041
0025   0000             RAM_CODE            .equ    $0057       ;The bottom of reset RAM
0026   0000             STACK               .equ    $01BF       ;The top of RAM
0027   0000             ;
0028   0000             ;...The Void...
0029   0000             ;
0030   0000             ;ROM
0031   0000             START               .equ    $8000       ;start address of the external rom
0032   8000                                 .org    START
0033   8000             ;
0034   8000             ;Strings
0035   8000 0A 4A 41 4E HELLOSTR            .text   "\nJANE HACKER 2022 <3\n"
0035   8004 45 20 48 41 
0035   8008 43 4B 45 52 
0035   800C 20 32 30 32 
0035   8010 32 20 3C 33 
0035   8014 0A 
0036   8015 00                              .byte   $00
0037   8016 52 45 41 44 READYSTR            .text   "READY"
0037   801A 59 
0038   801B 00                              .byte   $00
0039   801C 44 4F 4E 45 DONESTR             .text   "DONE"
0040   8020 00                              .byte   $00
0041   8021             ;
0042   8021             ;Subroutines
0043   8021             ;Print a char out the serial port
0044   8021 36          PCHAR               psha                ;save A
0045   8022 96 11       PCHAR1              ldaa    SCI_SCR     ;get comms status ;clears the TDRE bit
0046   8024 84 20                           anda    #$20        ;mask for tdre bit
0047   8026 27 FA                           beq     PCHAR1      ;wait till empty
0048   8028 32                              pula                ;restore A
0049   8029 97 13                           staa    SCI_TX      ;send it
0050   802B 39                              rts
0051   802C             ;
0052   802C             ;Read a char from the serial port
0053   802C 96 11       RCHAR               ldaa    SCI_SCR     ;get comms status ;clears the RDRF bit?
0054   802E 84 80                           anda    #$80        ;mask for rdrf bit
0055   8030 27 FA                           beq     RCHAR       ;wait till full
0056   8032 96 12                           ldaa    SCI_RX      ;read it
0057   8034 39                              rts                 ;the byte is now in acc. A
0058   8035             ;
0059   8035             ;Print a string out the serial port; expect start address of string in reg. D
0060   8035 3C          PSTR                pshx                ;Chuck ind. X onto the stack
0061   8036 1A                              xgdx                ;ind. X now has the string address
0062   8037 3C                              pshx
0063   8038 A6 00       PSTRLOOP            ldaa    $00,x       ;Load acc. A with data at address in X
0064   803A 81 00                           cmpa    #$00
0065   803C 27 06                           beq     PSTRDONE    ;If acc. A is zero (our "null byte")
0066   803E BD 80 21                        jsr     PCHAR       ;Print the char
0067   8041 08                              inx                 ;Increment X to the next byte
0068   8042 20 F4                           bra     PSTRLOOP    ;loop
0069   8044 38          PSTRDONE            pulx                ;restore acc. D
0070   8045 1A                              xgdx
0071   8046 38                              pulx                ;restore ind. X
0072   8047 39                              rts                 ;return
0073   8048             ;
0074   8048             ;Print the string READY to serial
0075   8048 CC 80 16    PREADY              ldd     #READYSTR   ;Point to start of "READY" string
0076   804B BD 80 35                        jsr     PSTR        ;Print string routine
0077   804E 39                              rts
0078   804F             ;
0079   804F             ;Print the string DONE to serial
0080   804F CC 80 1C    PDONE               ldd     #DONESTR    ;Point to start of "READY" string
0081   8052 BD 80 35                        jsr     PSTR        ;Print string routine
0082   8055 39                              rts
0083   8056             ;
0084   8056             ;Clear accumulators
0085   8056 4F          CLRACC              clra
0086   8057 5F                              clrb
0087   8058 39                              rts
0088   8059                                 ;
0089   8059             ;===================
0090   8059             ; Expects X=src start address, Y=dest start address, D=number of bytes to copy
0091   8059             ;===================
0092   8059                                 ;
0093   8059 CD DF 40    MEMCPY              sty     MC_START
0094   805C                                 ;
0095   805C D3 40                           addd    MC_START
0096   805E DD 41                           std     MC_STOP
0097   8060 EC 80       MC_LOOP             ldd     $00,y
0098   8062 ED 00                           std     $00,x
0099   8064 08                              inx
0100   8065 CD 08                           iny
0101   8067 DC 41                           ldd     MC_STOP
0102   8069 1E 00                           cpd     $00,x
0103   806B 25 F3                           bcs     MC_LOOP
0104   806D                                 ;
0105   806D 39                              rts
0106   806E             ;
0107   806E             ;Code
0108   806E 86 C0       ENTRYPOINT          ldaa    #$C0          ;to RAM enable
0109   8070 97 14                           staa    RAM_CTL       ;enable RAM
0110   8072             ;Clear RAM area
0111   8072 CE 00 40    CLRRAM              ldx     #RAM_BOT
0112   8075 86 00                           ldaa    #$00
0113   8077 A7 00       CRLOOP              staa    $00,x
0114   8079 08                              inx
0115   807A 8C 01 BF                        cpx     #STACK
0116   807D 23 F8                           bls     CRLOOP
0117   807F             ;Setup Stack
0118   807F 8E 01 BF                        lds     #STACK        ;setup the stack pointer
0119   8082             ;Setup Serial
0120   8082 86 05                           ldaa    #$05          ;setup SCI
0121   8084 97 10                           staa    SCI_BAUD
0122   8086 86 0A                           ldaa    #$0A          ;set acc. A to TE (Transmit Enable)
0123   8088                                 ;                     ;and RE (Recieve Enable) bit in SCI_SCR
0124   8088 97 11                           staa    SCI_SCR       ;enable transmitter and reciever
0125   808A                                 ;
0126   808A 4F                              clra                  ;Clear acc. A
0127   808B             ;Copy code from serial to RAM
0128   808B CE 00 57    COPYINIT            ldx     #RAM_CODE     ;Put start addr. of code in RAM into X
0129   808E                                 ;
0130   808E BD 80 48                        jsr     PREADY        ;Print "READY" to serial
0131   8091                                 ;
0132   8091 BD 80 2C    COPY                jsr     RCHAR         ;Load acc. A with code
0133   8094 A7 00                           staa    $00,x         ;Store acc. A into RAM code
0134   8096 08                              inx
0135   8097 A7 00                           staa    $00,x         ;Peek for end of instruction marker
0136   8099 81 FF                           cmpa    #$FF
0137   809B 26 F4                           bne     COPY
0138   809D             ;Wait for MCU to be ready
0139   809D                                 ;loop until ready signal recieved
0140   809D BD 80 2C    RDYLOOP             jsr     RCHAR       ;read in character
0141   80A0 91 FF                           cmpa    $FF         ;is it 0xFF?
0142   80A2 25 F9                           bcs     RDYLOOP     ;if CHAR - 0xFF <, loop
0143   80A4 BD 80 21                        jsr     PCHAR       ;echo
0144   80A7                                 ;
0145   80A7 CC 00 00                        ldd     #$0000
0146   80AA CE 00 00                        ldx     #$0000
0147   80AD CD CE 00 00                     ldy     #$0000
0148   80B1             ;Run the code copied into RAM
0149   80B1 7E 00 57    READY               jmp     RAM_CODE
0150   80B4             ;
0151   80B4             ;ISRs
0152   80B4 20 FE       sci_tr              bra     sci_tr
0153   80B6 20 FE       tof_tr              bra     tof_tr
0154   80B8 20 FE       ocf_tr              bra     ocf_tr
0155   80BA 20 FE       icf_tr              bra     icf_tr
0156   80BC 20 FE       irq_tr              bra     irq_tr
0157   80BE 20 FE       swi_tr              bra     swi_tr
0158   80C0 20 FE       nmi_tr              bra     nmi_tr
0159   80C2             ;
0160   80C2             ;Interrupt Vectors
0161   FFF0                                 .org     $FFF0
0162   FFF0                                 ;
0163   FFF0 80 B4                           .word    sci_tr
0164   FFF2 80 B6                           .word    tof_tr
0165   FFF4 80 B8                           .word    ocf_tr
0166   FFF6 80 BA                           .word    icf_tr
0167   FFF8 80 BC                           .word    irq_tr
0168   FFFA 80 BE                           .word    swi_tr
0169   FFFC 80 C0                           .word    nmi_tr
0170   FFFE 80 6E                           .word    ENTRYPOINT
0171   10000                                 .end
# tasm: Number of errors = 0
