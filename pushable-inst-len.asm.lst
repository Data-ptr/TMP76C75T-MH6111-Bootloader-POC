0001   0000             ; Jane Hacker 20 Feb 2022
0002   0000             ; Trys to get the length of instructions
0003   0000             ;
0004   0000                                 .msfirst
0005   0000             ;
0006   0000             ;Internal registers
0007   0000             ;
0008   0000             ;RAM
0009   0000             RAM_BBU_BOT         .equ    $0040           ;The bottom of "Battery Backup" RAM
0010   0000             RAM_BBU_TOP         .equ    $0056           ;The top of "Battery Backup" RAM
0011   0000             RAM_VIO_BOT         .equ    $0057           ;The bottom of "violate" RAM
0012   0000             RAM_VIO_TOP         .equ    $01BF           ;The top of "violate" RAM
0013   0000             RAM_CODE_START      .equ    RAM_VIO_BOT
0014   0000             ;
0015   0000             ;User RAM
0016   0000             IL1                 .equ    $0044           ;_I_nstruction _L_ength votes
0017   0000             IL2                 .equ    $0045
0018   0000             IL3                 .equ    $0046
0019   0000             IL4                 .equ    $0047
0020   0000             MAX_VOTE            .equ    $0048           ;$0048:$0049
0021   0000             MAX_INT             .equ    $004A
0022   0000             ;
0023   0000             ;Subroutines in ROM
0024   0000             PCHAR               .equ    $8021
0025   0000             RCHAR               .equ    $802C
0026   0000             PSTR                .equ    $8035
0027   0000             CLRACC              .equ    $8056
0028   0000             MEMCPY              .equ    $8059
0029   0000             ;
0030   0057                                 .org    RAM_CODE_START
0031   0057                                 ;
0032   0057 7E 00 91                        jmp     ENTRYPOINT
0033   005A                                 ;
0034   005A             ;Clear RAM area
0035   005A 86 00       CLRRAM              ldaa    #$00
0036   005C CE 00 44                        ldx     #IL1
0037   005F A7 00       CRLOOP              staa    $00,x
0038   0061 08                              inx
0039   0062 8C 00 4B                        cpx     #MAX_INT + 1
0040   0065 25 F8                           bcs     CRLOOP
0041   0067                                 ;
0042   0067 39                              rts
0043   0068                                 ;
0044   0068             ; Expects byte count to be in acc. A
0045   0068 16          STRVOTE             tab                     ;put A in B (effectively D)
0046   0069 86 00                           ldaa    #$00
0047   006B 01                              nop
0048   006C C3 00 44                        addd    #IL1            ;D is now the addr of the byte count
0049   006F 1A                              xgdx                    ;now X points to byte count
0050   0070 6C 00                           inc     $00,x
0051   0072                                 ;
0052   0072 39                              rts
0053   0073                                 ;
0054   0073 CE 00 44    FINDWINNER          ldx     #IL1            ;starting address
0055   0076 DF 48                           stx     MAX_VOTE        ;set as highest count
0056   0078 C6 00                           ldab    #$00
0057   007A                                 ;
0058   007A 08          FW_LOOP             inx                     ;is #IL2 on first loop
0059   007B 5C                              incb
0060   007C 18 DE 48                        ldy     MAX_VOTE        ;is #IL1 on first loop
0061   007F A6 80                           ldaa    $00,y           ;acc. A has the count at MAX_VOTE, Y++
0062   0081 A1 00                           cmpa    $00,x           ;cmp MAX_VOTE to IL(x)
0063   0083 24 04                           bcc     FW_CONT         ;if MAX_VOTE wins, continue
0064   0085 DF 48                           stx     MAX_VOTE        ;we have a new MAX_VOTE
0065   0087 D7 4A                           stab    MAX_INT
0066   0089 8C 00 47    FW_CONT             cpx     #IL4
0067   008C 24 EC                           bcc     FW_LOOP
0068   008E                                 ;
0069   008E 96 4A                           ldaa   MAX_INT
0070   0090                                 ;
0071   0090 39                              rts
0072   0091                                 ;
0073   0091 86 13       ENTRYPOINT          ldaa    #$13
0074   0093 BD 80 21                        jsr     PCHAR           ;puts the instruction byte on serial
0075   0096                                 ;
0076   0096 9D 5A                           jsr     CLRRAM          ;clear the ram we are using
0077   0098             ;
0078   0098             ;===================
0079   0098             ; Expects A=instr
0080   0098             ;===================
0081   0098             ;
0082   0098 97 A2       CNTBYTES            staa    $A2          ;copy in test instruction
0083   009A 97 AA                           staa    $AA
0084   009C 97 B4                           staa    $B4
0085   009E 97 C0                           staa    $C0
0086   00A0                                 ;
0087   00A0 86 04                           ldaa    #$04            ;Use A as a counter
0088   00A2 00          INSTR1              .byte   $00             ;Instruction byte
0089   00A3 4A                              deca
0090   00A4 4A                              deca
0091   00A5 4A                              deca
0092   00A6 9D 68                           jsr     STRVOTE
0093   00A8 C6 04                           ldab    #$04            ;Use B as a counter
0094   00AA 00          INSTR2              .byte   $00             ;Instruction byte
0095   00AB 5A                              decb
0096   00AC 5A                              decb
0097   00AD 5A                              decb
0098   00AE 17                              tba
0099   00AF 9D 68                           jsr     STRVOTE
0100   00B1 CE 00 04                        ldx     #$0004          ;Use X as a counter
0101   00B4 00          INSTR3              .byte   $00             ;Instruction byte
0102   00B5 09                              dex
0103   00B6 09                              dex
0104   00B7 09                              dex
0105   00B8 1A                              xgdx
0106   00B9 17                              tba
0107   00BA 9D 68                           jsr     STRVOTE
0108   00BC CD CE 00 04                     ldy     #$0004          ;Use Y as a counter
0109   00C0 00          INSTR4              .byte   $00             ;Instruction byte
0110   00C1 CD 09                           dey
0111   00C3 CD 09                           dey
0112   00C5 CD 09                           dey
0113   00C7 CD 1A                           xgdy
0114   00C9 17                              tba
0115   00CA 9D 68                           jsr     STRVOTE
0116   00CC                                 ;
0117   00CC                                 ;
0118   00CC 9D 73                           jsr     FINDWINNER
0119   00CE                                 ;
0120   00CE BD 80 21                        jsr     PCHAR
0121   00D1 39                              rts
0122   00D2                                 ;
0123   00D2                                 .end
# tasm: Number of errors = 0
